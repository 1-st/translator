# translate [ Using context cancellation in Go ]
# orginal url
https://www.sohamkamani.com/blog/golang/2018-06-17-golang-using-context-cancellation/

## content

# 如何使用go中context终止功能.

越来越多的人开始在工作上使用go,或许有一些时候会用到了context的库.context 更多的情况下应用在数据下游的处理上.例如发起一个http的请求或者从database 获取数据,又或者需要对go-routines的执行性能做分析.context更多的作用是通过向下游传输公共数据并且可以应用在所有的下游数据操作上.然后,或许很少人知道.context一个很重要的功能是可以在程序运行中进行终止和暂停操作.
本文中我们会介绍如何使用context中终止这一重要功能.我们会通过一些流程图和简单的代码示例,看如何让我们的应用(程序)更快并且更稳定.
# 我们为什么需要一个终止命令
总之,我们为了防止我们的系统做一些不必须要的工作.
让我们来考虑一个这样一个场景,一个http的web服务去请求数据库并且返回查询给用户(客户端). 如下图所示:
- https://www.sohamkamani.com/client-diagram-199c2b8faf7663c9b7e83de127012a6c.svg

如果这个请求是正常执行的,整个请求的生命周期如下图所示:

- https://www.sohamkamani.com/timing-ideal-ff6e4d831668b9da81c1c214224e4521.svg

但是如果客户端突然中止了请求会发生什么样的情况? 这种情况是容易出现的,例如:用户突然关闭了浏览器在数据请求过程中.如果没有终止,那么服务器和数据库将继续继续一些列的操作.在终止之后的服务器操作其实是一个资源上的浪费.

- https://www.sohamkamani.com/timing-without-cancel-4955e194034f42b5edd7632f1461c124.svg

理想状态下,我们是希望在客户端发生中断之后后续的所有资源都将终止.如下图所示,所有的节点上的工作将会全部终止(包括 http的了解和数据库的操作)
- https://www.sohamkamani.com/timing-with-cancel-2af484f735aab3022ea8d7a9a9c1b675.svg

# 下面我们进入正文, 在go中如何用context中的终止功能.

现在我们已经明确了我们的目的,就是为什么我们要有终止的操作,下面让我们看下如何用go来实现该功能.
因为这个终止的时间是一个和上下文紧密相关的在一个事物里,或者这个操作已经被执行完了.这仅是一个原生的功能绑在了context上.

这里有2个地方或许你需要去实现来达到终止的效果.
- 监听这个终止的事件.
- 发出终止的命令.

# 如何监听到终止的事件

context 类型提供了一个Done() 的方法,这个方法会返回一个空的结构体,这个结构体会接收到每次终止的指令. 要监听终止的事件 通过 使用 <- ctx.Done() 是非常容易的一个事.

下面我们来实现一个列子,让我们考虑下,如果有这样一个的web服务,每次处理一个请求的事件需要花费2秒钟,我们的预期结果是立即返回一个数据当在正常请求完成之前收到了终止指令.
代码如下:

func main() {
	// Create an HTTP server that listens on port 8000
	http.ListenAndServe(":8000", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		// This prints to STDOUT to show that processing has started
		fmt.Fprint(os.Stdout, "processing request\n")
		// We use `select` to execute a peice of code depending on which
		// channel receives a message first
		select {
		case <-time.After(2 * time.Second):
			// If we receive a message after 2 seconds
			// that means the request has been processed
			// We then write this as the response
			w.Write([]byte("request processed"))
		case <-ctx.Done():
			// If the request gets cancelled, log it
			// to STDERR
			fmt.Fprint(os.Stderr, "request cancelled\n")
		}
	}))
}




